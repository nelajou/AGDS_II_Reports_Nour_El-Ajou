---
title: "Exersice Spatial Upscaling"
author: "Nour El-Ajou"
date: "2023-12-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```





# 2.1 Literature

Read the paper by Ludwig et al. (2023) and answer the following questions:


## 2.1.1
Explain the difference between a random cross-validation and a spatial cross-validation.

Answer:

Random CV divides the  Data randomly into k Folds, which then are subsequently used to train the model. k times, another of these folds is then used as the Test data and the k-1 other folds as the Training data. After evalutating all of these models, the mean performance can be calculated. 

Random CV generates folds by random samples from the data set at hand. If this data is representative of the Actual Prediction space, RC should return reasonable metrics. 
But if this is not the case, e.g. if one has strongly clustered data, random CV will reproduce this clustering within its folds. 

The main assumption in this context is the independence between different datapoints, which is normally not given for geographical data (i.e. Datapoints near of each other tend to be more similar, which violates there independence. )

Consequently it might be useful to generate folds not randomly, but divide the data based on a different, predefined criteria that reduces the clustering within these folds. Since there is much more environmental data available from the northern, western hemisphere than from all others, one straight forward idea would be to build folds based on geographic clusters and then do the CV. This ist the basic idea of Spatial clustering. Of course, these distances don't have to be measured in geographical space, but can indicate any distance between any variable that might be relevant. 

By building folds which represent different clusters, all of them attribute equally to the final model performance, calculated by the mean of all k Training rounds. Consequently, this would counteract the tendency of the resulting model to heavily represent the most prominent clusters to some extent. 


### Check if its trainings or validation data

# 2.1.2

In spatial upscaling, we model the target based on environmental covariates. This implies that we assume the training data to sufficiently represent the conditions on which the model will be applied for generating predictions. Prediction errors may increase with an increasing distance of the prediction location from the training locations.

The paper by Ludwig et al. (2023) considers this “distance” as a geographical distance in Euclidian space. Do you see an alternative to measuring a distance that considers the task of spatial upscaling based on environmental covariates more directly?

Answer: 

One could still take the Euclidean space, not for geographical distance but the distances of the covariates themselves. Through this, the validity of the estimates, depending on different regions would be more directly linked to the covariate space represented in the training data. 

At the same time geographical distance doesn't seem like a very reasonable indicator, since an extreme high variation of environmental conditions might be encountered in very close geographic space (e.g. through variations in altitude or passing of natural barriers, such as waterbodies and mountain ranges). Consequently, the replacement of this metric by an other does seem reasonable. 


# 2.2 Random Cross Validation

Use Random Forest to perform a 5-fold cross-validation with the leaf N data (leafN) and the following predictors:

elv: Elevation above sea level (m)
mat: mean annual temperature (degrees Celsius)
map: mean annual precipitation (mm yr
)
ndep: atmospheric nitrogen deposition g m
 yr
mai: mean annual daily irradiance µ
mol m
 s
Species: species name of the plant on which leaf N was measured
Report the mean RMSE and R
 across cross-validation folds. Chose hyperparameters as mtry = 3 and min.node.size = 12 and others as their default in ranger::ranger().
 
## Packages

```{r, echo = FALSE}
library(tidyverse)

list.of.packages <- c("ggplot2","skimr", "tidyverse", "caret", "OneR", "dplyr", "kableExtra", "visdat")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only=TRUE)
```
 
## Data 
 
```{r, echo = FALSE}
rm(list = ls())

df <- readr::read_csv("https://raw.githubusercontent.com/stineb/leafnp_data/main/data/leafnp_tian_et_al.csv")
```


```{r}
common_species <- df |> 
  dplyr::group_by(Species) |> 
  dplyr::summarise(count = n()) |> 
  dplyr::arrange(desc(count)) |> 
  dplyr::slice(1:50) |> 
  dplyr::pull(Species)

dfs <- df |> 
  dplyr::select(leafN, lon, lat, elv, mat, map, ndep, mai, Species) |> 
  filter(Species %in% common_species)

```


```{r, echo = FALSE}
# Data splitting
split <- rsample::initial_split(dfs, prop = 0.7, strata = "Species")
df_train <- rsample::training(split)
```



```{r, echo = FALSE}
# show missing data
visdat::vis_miss(dfs)
dfs$Species <- dfs$Species |> as.factor()

```
## Formulate model

```{r}
# The same model formulation is in the previous chapter
pp <- recipes::recipe(leafN ~ elv + mat + map + ndep + mai + Species, 
                      data = df_train) |> 
  recipes::step_center(recipes::all_numeric(), -recipes::all_outcomes()) |>
  recipes::step_scale(recipes::all_numeric(), -recipes::all_outcomes())
```


## Train RF with 5 - fold random CV
```{r}
# Load required libraries
library(caret)
library(ranger)

# Set seed for reproducibility
set.seed(199)

# Create a data frame to store results
results <- data.frame()

rf_1000_5 <- caret::train(
  pp, 
  data = df_train |> 
    drop_na(), 
  method = "ranger",
  metric = "RMSE",
  trControl = trainControl(
    method = "cv",
    number = 5,
    savePredictions = "final"
    ),
  tuneGrid = expand.grid(
    .mtry = 3,        # default p/3
    .min.node.size = 12,          
    .splitrule = "variance"      # default "variance"
  ),
  # arguments specific to "ranger" method
  num.trees = 1000
)
```

## Show Results
```{r}
print(rf_1000_5)
```


```{r}
# OOB prediction error of the final model
oob.bas <- sqrt(rf_1000_5$finalModel$prediction.error)

cat("the obb of the basic model is", oob.bas)
```


```{r}
# RMSE of 5-fold cross-validation
rmse.bas <- rf_1000_5$results$RMSE

cat("the RMSE of the basic model is", rmse.bas)

```


```{r}
# Rsquared of 5-fold cross-validation
r2.bas <- rf_1000_5$results$Rsquared
cat("the R2 of the basic model is", r2.bas)

```

 # 2.3 Spatial Crossvalidation
 
Here is the distribution of our data across the globe.


## Packages
```{r}
# DISPLAYING SPATIAL DISTRIBUTION
list.of.packages <- c("sf", "rnaturalearth", "rnaturalearthdata", "cowplot")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, library, character.only=TRUE)
```

## Show Clustering
```{r}
# get coast outline
coast <- rnaturalearth::ne_coastline(scale = 110, returnclass = "sf")

ggplot() +

  # plot coastline
  geom_sf(data = coast,
          colour = 'black',
          size = 0.2) +

  # set extent in longitude and latitude
  coord_sf(
    ylim = c(-60, 80),
    expand = FALSE) +  # to draw map strictly bounded by the specified extent
  
  # plot points on map
  geom_point(data = dfs, aes(x = lon, y = lat), color = "red", size = 0.2) +
  labs(x = "", y = "") +
  theme(legend.position = "bottom")
```
## 2.3.1

What do you observe? Discuss the potential implications of the geographical distribution of data points for spatial upscaling.

The wast majoritiy of the datapoints is in Europe and Eastern parts of China. There are some datapoints in North - and South-America, one in northern Africa and some widely dispersed points in central Asia. Consequently, the northern Hemisphere is widely over represented, especially European environment, alongside the northern Monsuun regions in China. Thus c.p., we would expect our model to show a bias  towards environmental conditions, similar to these. 
 
 
 
 Perform a spatial cross-validation. 
 
 To do so, first identify geographical clusters of the data using the k-means algorithm (an unsupervised machine learning method), considering the longitude and latitude of data points and setting 
 

Plot points on a global map, showing the five clusters with distinct colors.
 ## Generate regional clusters
```{r, echo = FALSE}
# K-Means algorithm
clusters <- kmeans(
  dfs |> dplyr::select(lon, lat),
  centers = 5
)

#add to dataset
dfs <- cbind(dfs, clusters[["cluster"]]) |> rename(cluster = 10)
```

## Plot regional clusters
```{r, echo = FALSE}
ggplot() +

  # plot coastline
  geom_sf(data = coast,
          colour = 'black',
          size = 0.3) +

  # set extent in longitude and latitude
  coord_sf(
    ylim = c(-60, 80),
    expand = FALSE) +  # to draw map strictly bounded by the specified extent
  
  # plot points on map
  geom_point(data = dfs, aes(x = lon, y = lat, col = as.factor(cluster)),
             size = 0.5) +
  labs(x = "", y = "", col = "Cluster") +
  theme(legend.position = "bottom") +
  guides(colour = guide_legend(override.aes = list(size=5)))
```


## 2.3.2 Plot the distribution of leaf N by cluster.

```{r, echo = FALSE}
# Distribution curve plot
curve_plot <- ggplot(dfs, aes(x = leafN, color = as.factor(cluster))) +
  geom_density(alpha = 0.7) +
  labs(x = "Leaf N content (%)", y = "Density", col = "Cluster") +
  theme_minimal()

# Boxplot plot
boxplot_plot <- ggplot(dfs, aes(x = cluster, y = leafN, fill = as.factor(cluster))) +
  geom_boxplot() +
  labs(x = "Cluster", y = "Leaf N content (%)", fill = "Cluster") +
  theme_minimal()

# Combine both plots using cowplot package
combined_plot <- plot_grid(curve_plot, boxplot_plot, ncol = 2, labels = c("A", "B"))

print(combined_plot)
```

## 5.2.3
Split your data into five folds that correspond to the geographical clusters identified by in (2.).

fit a random forest model with the same hyperparameters as above and performing a 5-fold cross-validation with the clusters as folds.

Report the RMSE and the R
 determined on each of the five folds

## Data Split
```{r}
# create folds based on clusters
group_folds_train <- purrr::map(
  seq(length(unique(dfs$cluster))),
  ~ {
    dfs |> 
      select(cluster) |> 
      mutate(idx = 1:n()) |> 
      filter(cluster != .) |> 
      pull(idx)
  }
)

group_folds_test <- purrr::map(
  seq(length(unique(dfs$cluster))),
  ~ {
    dfs |> 
      select(cluster) |> 
      mutate(idx = 1:n()) |> 
      filter(cluster == .) |> 
      pull(idx)
  }
)
```


## Train random forest
```{r}
# create a function that trains a random forest model on a given set of rows and 
# predicts on a disjunct set of rows
train_test_by_fold <- function(train_idx, val_idx) {
  
  # Train the model
  mod <- ranger(
    formula = leafN ~ elv + mat + map + ndep + mai + Species, 
    data = dfs[train_idx, ],
    mtry = 3,
    min.node.size = 12,
    num.trees = 500
  )

 
# Predict on the validation set
  pred <- predict(mod, data = dfs[val_idx, ])
  
  # Calculate R-squared on the validation set
  rsq <- cor(pred$predictions, dfs$leafN[val_idx])^2
  
  # Calculate RMSE on the validation set
  rmse <- sqrt(mean((pred$predictions - dfs$leafN[val_idx])^2))
  
  return(tibble(rsq = rsq, rmse = rmse))
}

# apply function on each custom fold and collect validation results in a nice
# data frame
output <- purrr::map2_dfr(
  group_folds_train,
  group_folds_test,
  ~train_test_by_fold(.x, .y)
) |> 
  mutate(test_fold = 1:5)

print(output)
```
```{r}
print(mean(output$rmse))
```


Compare the results of the spatial cross-validation to the results of the random cross-validation and discuss reasons for why you observe a difference in the cross-validation metrics (if you do).

# Environmental Clustering

2.4 Environmental cross-validation
The central rationale for spatial uspcaling is that we can model based on relationships between the target variable and the environment. The geographic location is not among the predictors. Thus, as long as the training data covers a wide enough range of environmental conditions, we can model for any new location where environmental conditions are within that range, irrespective of its geographical position. The challenge is just that the training data often doesn’t cover all environmental conditions of the globe, yet upscaling is often done for the globe.

Anyways, let’s probe the generalisability of a model not in geographical space, but in environmental space.

To do so, perform a custom cross-validation as above, but this time considering five clusters of points not in geographical space, but in environmental space - spanned by the mean annual precipitation and the mean annual temperature. Report the R-squared and the RMSE on the validation set of each of the five folds.
Compare the results of the environmental cross-validation to the results of the random and the spatial cross-validation and discuss reasons for why you observe a difference in the cross-validation metrics (if you do).



```{r, echo = FALSE}

dfs$map <- (dfs$map-mean(dfs$map) )/sd(dfs$map)
dfs$mat <- (dfs$mat-mean(dfs$mat) )/sd(dfs$mat)
clusters_env <- kmeans(
  dfs |> dplyr::select(map, mat),
  centers = 5
)

dfs <- cbind(dfs, clusters_env[["cluster"]]) |> rename(cluster_env = 11)

ggplot() +

  # plot coastline
  geom_sf(data = coast,
          colour = 'black',
          size = 0.3) +

  # set extent in longitude and latitude
  coord_sf(
    ylim = c(-60, 80),
    expand = FALSE) +  # to draw map strictly bounded by the specified extent
  
  # plot points on map
  geom_point(data = dfs, aes(x = lon, y = lat, col = as.factor(cluster_env)),
             size = 0.5) +
  labs(x = "", y = "", col = "Environmental Cluster",
       title = "Environmental Clusters based on mean annual temperature and precipitation") +
  theme(legend.position = "bottom") +
  guides(colour = guide_legend(override.aes = list(size=5)))

```


```{r, echo = FALSE}
# create folds based on envrionmental clusters
group_folds_train <- purrr::map(
  seq(length(unique(dfs$cluster_env))),
  ~ {
    dfs |> 
      select(cluster_env) |> 
      mutate(idx = 1:n()) |> 
      filter(cluster_env != .) |> 
      pull(idx)
  }
)

group_folds_test <- purrr::map(
  seq(length(unique(dfs$cluster_env))),
  ~ {
    dfs |> 
      select(cluster_env) |> 
      mutate(idx = 1:n()) |> 
      filter(cluster_env == .) |> 
      pull(idx)
  }
)

# create a function that trains a random forest model on a given set of rows and 
# predicts on a disjunct set of rows
train_test_by_fold <- function(train_idx, val_idx) {
  
  # Train the model
  mod <- ranger(
    formula = leafN ~ elv + mat + map + ndep + mai + Species, 
    data = dfs[train_idx, ],
    mtry = 3,
    min.node.size = 12,
    num.trees = 1000
  )
  
  # Predict on the validation set
  pred <- predict(mod, data = dfs[val_idx, ])
  
  # Calculate R-squared on the validation set
  rsq <- cor(pred$predictions, dfs$leafN[val_idx])^2
  
  # Calculate RMSE on the validation set
  rmse <- sqrt(mean((pred$predictions - dfs$leafN[val_idx])^2))
  
  return(tibble(rsq = rsq, rmse = rmse))
}

# apply function on each custom fold and collect validation results in a nice
# data frame
output_env <- purrr::map2_dfr(
  group_folds_train,
  group_folds_test,
  ~train_test_by_fold(.x, .y)
) |> 
  mutate(test_fold = 1:5)

output_env

```
```{r}
print(mean(output_env$rmse))
```


```{r}
n_cluster_geo <- table(dfs$cluster)
n_cluster_env <- table(dfs$cluster_env)

n_cluster_geo
n_cluster_env
```

